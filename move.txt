class Move:

#constructor with parameters

def __init__(self,cooperate=True):

self.__cooperate=cooperate

#method to return string representation of object

def __str__(self):

if self.__cooperate:

return '.'

else:

return 'x'

#method to return formal string representation of object

def __repr__(self):

if self.__cooperate:

return 'Move(True)'

else:

return 'Move(False)'

#method to return if given and current object are equal

def __eq__(self,other):

return self.__cooperate==other.__cooperate

#method to change cooperation of current object

def change(self):

self.__cooperate=not self.__cooperate

#method to create and return a new object with the cooperation of current object

def copy(self):

return Move(self.__cooperate)

#method to calculate and return turn payout for a round of moves

def turn_payouts(move_a,move_b):

if move_a.__str__()=='.' and move_b.__str__()=='.':

return (2,2)

if move_a.__str__()=='x' and move_b.__str__()=='x':

return (0,0)

if move_a.__str__()=='x' and move_b.__str__()=='.':

return (3,-1)

if move_a.__str__()=='.' and move_b.__str__()=='x':

return (-1,3)

#testing the function

a=Move(False)

b=Move()

c=a.copy()

d=b.copy()

print('a:',a.__repr__())

print('b:',b.__repr__())

print('c:',c.__repr__())

print('d:',d.__repr__())

print('a vs b:',turn_payouts(a,b))

print('b vs c:',turn_payouts(b,c))

print('a vs c:',turn_payouts(a,c))

print('b vs d:',turn_payouts(b,d))